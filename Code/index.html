<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf8">

    <title>WebGL Ocean</title>
    <style>
      body {
          margin: 0;
          font-family: monospace;
      }
      canvas {
          display: block;
          width: 100vw;
          height: 100vh;
      }
      #b {
        position: absolute;
        top: 10px;
        width: 100%;
        text-align: center;
        z-index: 2;
      }
    </style>
  </head>
  <body>
    <canvas id="c"></canvas>
  </body>
  <script id="vs" type="notjs">
#version 300 es

precision mediump float;

in vec4 position;
in vec2 texcoord;
    
out vec2 texCoordV;
    
void main() {
  
  gl_Position = position;
  texCoordV = texcoord;
}

  </script>
  <script id="h0kfs" type="notjs">
#version 300 es

precision mediump float;

in vec2 texCoordV;

#define M_PI 3.1415926535897932384626433832795
#define G 9.81


uniform int width;
uniform int L;

uniform vec2 windDir;
uniform float windSpeed;
uniform float depth;

uniform int randomDistribution; // Normal distribution
uniform int spectrum;
uniform int dispersionMode;
uniform int directionalMode;
uniform float spectrumScale;

uniform float fetch;
uniform float swell;
uniform float Hs;

// JONSWAP parameters
uniform float JONSWAP_gamma;
uniform float JONSWAP_sigmaA;
uniform float JONSWAP_sigmaB; 

// Bretschneider Param
uniform float Bretschneider_wm;

// Ochi parameters
uniform float Ochi_lambda1, Ochi_wm1, Ochi_Hs1, Ochi_lambda2, Ochi_wm2, Ochi_Hs2;


uniform int propagate;

layout (location = 0) out vec4 h0k; 


//http://amindforeverprogramming.blogspot.com/2013/07/random-floats-in-glsl-330.html
uint hash( uint x ) {
    x += ( x << 10u );
    x ^= ( x >>  6u );
    x += ( x <<  3u );
    x ^= ( x >> 11u );
    x += ( x << 15u );
    return x;
}

// Compound versions of the hashing algorithm I whipped together.
uint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }

// Construct a float with half-open range [0:1] using low 23 bits.
// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.
float floatConstruct( uint m ) {
    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask
    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32

    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)
    m |= ieeeOne;                          // Add fractional part to 1.0

    float  f = uintBitsToFloat( m );       // Range [1:2]
    return f - 1.0;                        // Range [0:1]
}

// Pseudo-random value in half-open range [0:1].
float random( uvec2  v ) { return floatConstruct(hash(v)); }


//#define TEXTURE_GRADS

//#define USE_NOISE

#define COMPUTE_SKY_FOR_REFLECTION

// foam
#define NO_FOAM 0
#define USE_JACOBIAN 1
#define USE_VERTICAL_ACCELERATION 2
#define FOAM USE_JACOBIAN

//#define TESTING_COLOR_DEPTHS
//#define TESTING_COLORS	

#define M_PI 3.1415926535897932384626433832795
#define G 9.81

#define RANDOM_UNIFORM 0
// normal dist can be computed with Box-Muller transform
#define RANDOM_NORMAL 1
// if X is from a normal distribution, then exp(X) follows a log distribution
#define RANDOM_LOG 2
// if X is uniform on [0,1] then âˆ’log(X) follows an exponential distribution
#define RANDOM_EXP 3


#define DISPERSION_DEEP 0
#define DISPERSION_SHALLOW 1
#define DISPERSION_ CAPILLARY 2 


#define DIRECTIONAL_COS_POWER 0
#define DIRECTIONAL_MITSUYASU 1
#define DIRECTIONAL_HASSELMANN 2
#define DIRECTIONAL_DONNELAN_BANNER 3
#define DIRECTIONAL_HORVATH_MITSUYASU 4
#define DIRECTIONAL_HORVATH_HASSELMANN 5
#define DIRECTIONAL_HORVATH_DONNELAN_BANNER 6

#define SPECTRUM_PHILLIPS 0
#define SPECTRUM_PIERSON_MOSKOWITZ 1
#define SPECTRUM_JONSWAP 2
#define SPECTRUM_DONNELAN_JONSWAP 3
#define SPECTRUM_TMA 4
#define SPECTRUM_UNIFIED 5
#define SPECTRUM_PIERSON_MOSKOWITZ_HS 6
#define SPECTRUM_BRETSCHNEIDER 7
#define SPECTRUM_OCHI 8
#define SPECTRUM_OCHI_HS 9



// ------------------------------
// Dispersion
// ------------------------------

float getDispersionW(float k, float depth, int dispersionMode) {

	float tension = 0.074; // N/m
	float density = 1000.0; // Kg/m3
	
	// deep waters
	if (dispersionMode == DISPERSION_DEEP) 
		return sqrt(k * G);
	// shallow waters	
	else if (dispersionMode == DISPERSION_SHALLOW)	
		return sqrt(k * G * tanh(k*depth));
	else  // DISPERSION_ CAPILLARY
		return sqrt((G * k + pow(k,3.0) * tension/density) * tanh(k*depth));
}


float getDispersionDerivative(float k, float depth, int dispersionMode) {

	float tension = 0.074; // N/m
	float density = 1000.0; // Kg/m3
	float w = getDispersionW(k, depth, dispersionMode);
	
	// deep waters
	if (dispersionMode == DISPERSION_DEEP) 
		return G * 0.5f / w; 
	// shallow waters	
	else if (dispersionMode == DISPERSION_SHALLOW) {
		float dk = depth * k;
		float th = tanh(dk);
		return 0.5f * sqrt(9.81f / (k*th)) * (th + dk*(1.0 - th*th));
	}
	else { // DISPERSION_ CAPILLARY
		float dk = depth * k;
		float th = tanh(dk);
		float b = tension/density;
		return 0.5f * ((9.81f + 3.0 * b*k*k)*th + dk * (k*k*b + 9.81f) * pow(1.0f / cosh(dk), 2.0)) / w;
	}
}






// ------------------------------
// Directional Spreaading
// ------------------------------

// Taken from:
// https://buildbot.libretro.com/assets/frontend/bundle/shaders/shaders_glsl/crt/shaders/crt-royale/port-helpers/special-functions.h

float gamma_impl(const float s) {
	float s_inv = 1.0/s;
    //  Float version:
	float g = 1.12906830989;
	float c0 = 0.8109119309638332633713423362694399653724431;
	float c1 = 0.4808354605142681877121661197951496120000040;
	float e = 2.71828182845904523536028747135266249775724709;
	float sph = s + 0.5;
	float lanczos_sum = c0 + c1/(s + 1.0);
	float base = (sph + g)/e;
	return (pow(base, sph) * lanczos_sum) * s_inv;
}


float numericalIntegrationCos(float two_s) {

	float theta;
	float steps = 64.0;
	int isteps = 64;
	float sum = 0.0f;
	for (int i = 1; i < isteps - 1; ++i) {
		theta = -M_PI + float(i) * (2.0 * M_PI) / steps;
		sum += pow(abs(cos(theta* 0.5)), two_s);
	}

	float s0 = 0.0; //pow(abs(cos(-M_PI * 0.5)), two_s);
	float sn = 0.0; //pow(abs(cos(M_PI * 0.5)), two_s);
	sum = (sum + 0.5 * (float(s0) + float(sn)))  * (2.0 * M_PI) / steps;

	return sum;
}


float auxDonelan(float w, vec2 waveDir, vec2 windDir, float wPeak, float swell) {

	float cos_angle = dot(waveDir,windDir);
	if (cos_angle < -1.0)
		cos_angle = -1.0;
	else if (cos_angle > 1.0)
		cos_angle = 1.0;	
	float wave_angle = acos(cos_angle);
	float wcoeff = w / wPeak;
	float epsilon = -0.4f + 0.8393f * exp(-0.567f * log(pow(wcoeff, 2.0)));
	float beta;
	if (wcoeff < 0.95f)
		beta = 2.61f * pow(wcoeff, 1.3f);
	else if (wcoeff < 1.6f)
		beta = 2.28f * pow(wcoeff, -1.3f);
	else
		beta = pow(10.0f, epsilon);
	return beta / (2.0 * tanh(beta * M_PI)) * pow(1.0 / cosh(beta * wave_angle), 2.0);
}


float auxHorvath(float w, vec2 waveDir, vec2 windDir, float wPeak, float swell) {			// compute Horvath factor
	float cos_angle = dot(waveDir,windDir);
	if (cos_angle < -1.0)
		cos_angle = -1.0;
	float half_angle_cos = sqrt((1.0 + cos_angle) / 2.0);
	float s = 16.0 * tanh(wPeak / w) * swell;
	float qs = pow(2.0, 20. * s - 1.0) / M_PI * pow(gamma_impl(s + 1.0), 2.0) / gamma_impl(2.0 * s + 1.0);
	return qs * pow(abs(half_angle_cos), 2.0 * s);
}


float getDirectionalSpreading(int directionalMode, float w, float wPeak, vec2 waveDir, vec2 windDir, float windSpeed, float swell) {

	float cos_angle, half_angle_cos, s, sp, qs, wave_angle, wcoeff, epsilon, beta, norm, theta;

	switch(directionalMode) {
		// Massel (2018) - Ocean surface waves: their physics and precdiction
		//	"Historically, the first attempt to model directional energy spreading was
		//	suggested by Pierson et al. (1955) in the form of the cosine type function"
		case DIRECTIONAL_COS_POWER: 
			float cos_angle = dot(waveDir, windDir);
			if (cos_angle > 0.0)
				return 2.0/M_PI * pow(cos_angle,2.0);
			else
				return 0.0;

		// Mitsuyasu (1975)
		case DIRECTIONAL_MITSUYASU:
			cos_angle = dot(waveDir, windDir);
			if (cos_angle < -1.0)
				cos_angle = -1.0;
			half_angle_cos = sqrt(( 1.0 + cos_angle)/2.0);
			sp = 11.5 * pow((wPeak * windSpeed /G),-2.5);
			if (w <= wPeak)
				s = sp * pow(w / wPeak, 5.0);
			else
				s = sp * pow(w / wPeak, -2.5f);
			norm = numericalIntegrationCos(2.0*s);
			return 	pow(abs(half_angle_cos), 2.0*s) / (norm + 0.00001);
			//qs = pow(2.0, 2.0*s-1.0) / M_PI * pow(gamma_impl(s+1.0), 2.0)/ gamma_impl(2.0*s +1.0);
			//return qs * pow(abs(half_angle_cos), 2*s);

		// Mitsuyasu: see Emprirical Directional Wave Spectra, Horvath, 2015
		case DIRECTIONAL_HORVATH_MITSUYASU:
			cos_angle = dot(windDir,waveDir);
			if (cos_angle < -1.0)
				cos_angle = -1.0;
			half_angle_cos = sqrt((1.0+ cos_angle)/2.0);
			sp = 11.5 * pow((wPeak * windSpeed /G),-2.5);
			if (w <= wPeak)
				s = sp * pow(w / wPeak, 5.0);
			else
				s = sp * pow(w / wPeak, -2.5f);
			// swell term	
			s += 16.0 * tanh(wPeak/w) * swell;
			norm = numericalIntegrationCos(2.0*s);
			return pow(abs(half_angle_cos), 2.0*s) / norm;
			//qs = pow(2.0, 2.0*s-1.0) / M_PI * pow(gamma_impl(s+1.0), 2.0)/ gamma_impl(2.0*s +1.0);
			//return qs * pow(abs(half_angle_cos), 2.0*s);

		// Hasselmann 1980
		case DIRECTIONAL_HASSELMANN:

			cos_angle = dot(windDir,waveDir);
			if (cos_angle < -1.0)
				cos_angle = -1.0;
			half_angle_cos = sqrt((1.0 + cos_angle) * 0.5);
			sp = 11.5 * pow((wPeak * windSpeed /G),-2.5);
			if (w <= wPeak)
				s = 6.97f * pow(w / wPeak, 4.06f);
			else
				s = 9.77f * pow(w / wPeak, -2.33f - 1.45f*((windSpeed * wPeak / 9.81f) - 1.17f));
			norm = numericalIntegrationCos(2.0*s);
			return 	pow(abs(half_angle_cos), 2.0*s) / norm;
			//qs = pow(2, 2*s-1) / M_PI * pow(gamma_impl(s+1), 2)/ gamma_impl(2*s +1);
			//return qs * pow(abs(half_angle_cos), 2*s);
			
		// Hasselmann: see Emprirical Directional Wave Spectra, Horvath, 2015
		case DIRECTIONAL_HORVATH_HASSELMANN:

			cos_angle = dot(windDir,waveDir);
			if (cos_angle < -1.0)
				cos_angle = -1.0;
			half_angle_cos = sqrt((1.0 + cos_angle)/2.0);
			sp = 11.5 * pow((wPeak * windSpeed /G),-2.5);
			if (w <= wPeak)
				s = 6.97f * pow(w / wPeak, 4.06f);
			else
				s = 9.77f * pow(w / wPeak, -2.33f - 1.45f*((windSpeed * wPeak / 9.81f) - 1.17f));
			// swell term	
			s += 16.0 * tanh(wPeak/w) * swell;
			norm = numericalIntegrationCos(2.0*s);
			return 	pow(abs(half_angle_cos), 2.0*s) / norm;
			//qs = pow(2, 2*s-1) / M_PI * pow(gamma_impl(s+1), 2)/ gamma_impl(2*s +1);
			//return qs * pow(abs(half_angle_cos), 2*s);
			
		// Donelan-Banner : see Emprirical Directional Wave Spectra
		case DIRECTIONAL_DONNELAN_BANNER:
			cos_angle = dot(windDir,waveDir);
			if (cos_angle < -1.0)
				cos_angle = -1.0;
			else if (cos_angle > 1.0)
				cos_angle = 1.0;	
			wave_angle = acos(cos_angle);
			wcoeff = w/wPeak;
			epsilon = -0.4 + 0.8393 * exp( -0.567 * log(pow(wcoeff,2.0)));


			if (wcoeff < 0.95)
				beta = 2.61 * pow(wcoeff, 1.3);
			else if (wcoeff < 1.6)
				beta = 2.28 * pow(wcoeff, -1.3);
			else
				beta = pow(10.0,epsilon);
			return beta / (2.0 * tanh(beta * M_PI)) * pow(1.0 / cosh(beta * wave_angle), 2.0);;

		// Donelan-Banner: see Emprirical Directional Wave Spectra, Horvath, 2015	
		case DIRECTIONAL_HORVATH_DONNELAN_BANNER:
			vec2 wDir; float sum = 0.0;
			for (int i = 1; i < 30; ++i) {
				theta = -M_PI + (float(i) + 1.0) * 2.0 * M_PI / 32.0;
				wDir = vec2(cos(theta), sin(theta));
				sum += auxDonelan(w, wDir, windDir, wPeak, swell) * auxHorvath(w, wDir, windDir, wPeak, swell);
			}
			wDir = vec2(cos(-M_PI), sin(-M_PI));
			float f0 = auxDonelan(w, wDir, windDir, wPeak, swell) * auxHorvath(w, wDir, windDir, wPeak, swell);

			wDir = vec2(cos(M_PI), sin(M_PI));
			float fn = auxDonelan(w, wDir, windDir, wPeak, swell) * auxHorvath(w, wDir, windDir, wPeak, swell);
			
			norm = (sum + 0.5f * (f0 + fn))  * (2.0 * M_PI / 32.0);

			return auxDonelan(w, waveDir, windDir, wPeak, swell) * auxHorvath(w, waveDir, windDir, wPeak, swell) / norm;
	
		
	}
	
}

// -----------------------------
// Spectra in wave number format
// -----------------------------
// Chen, Li-ning and Jin, Yi - cheng and Yin, Yong and Ren, Hong-xiang
// On the Wave Spectrum Selection in Ocean Wave Scene Simulation of the Maritime Simulator
// AsiaSim 2013     A = 3.48e-3f

float Phillips(vec2 vec_k, float windSpeed, vec2 windDir) 
{
	if (vec_k == vec2(0.0f, 0.0f))
		return 0.0f;
        
    // Largest possible waves arising from a continuous wind of speed V
	float L = windSpeed*windSpeed / G; 

	float k = length(vec_k);
	vec2 k_hat = normalize(vec_k);
	float dot_k_w = dot(k_hat, normalize(windDir));
	float result = 3.48e-3 * exp(-1.0 / (k*L*k*L)) / pow(k, 4.0) * pow(dot_k_w, 2.0);

    // suppressing very small waves ( l << L
	float l = 0.1;//0.00001 * L * L;
	result *= exp(-k*k*l*l);  // Eq24

	return result;
}

// ------------------------------
// Frequency Spectra
// ------------------------------


// From original article by Pierson and Moskowitz (1964) Journal of Geophysical Research
// The scaling coefficient 1.026 is to compensate the fact that in PM the wind is 
// measured at 19.5 mt, whereas in all other works a height of 10 mts is considered
// U19.5 â‰ˆ 1.026 U10 (Stewart, 2006)
// the function below takes winds at 10 mt above sea level
float Pierson_Moskowitz(float windSpeed, float w) 
{
	// s(w)
	float wp = 0.879 * G / (1.026 * windSpeed);
	float expTerm = -1.25 * pow(wp/w,4.0) ;
	float result = 8.1e-3 * G * G * pow(w, -5.0) * exp(expTerm);
	return result;
}


// Pierson - Moskowitz defined as a function of significant wave height
// Ochi, pg 35
// https://ocw.mit.edu/courses/mechanical-engineering/2-22-design-principles-for-ocean-vehicles-13-42-spring-2005/readings/lec6_wavespectra.pdf
float PiersonMoskowitzHs(float w) {

	float expTerm = -0.032 * pow(G / (Hs), 2.0) * pow(w, -4.0);
	float result = 8.1e-3 * pow(G, 2.0) * pow(w, -5.0) * exp(expTerm);
	return result;
}


// Bretschneider two parameter spectrum: Hs and wm
// setting wm = 0.4 sqrt(g/Hs) reverts to Pierson-Moskowitz
// Ochi, pg 36
float Bretschneider(float w) {

	float expTerm = -1.25f * pow(Bretschneider_wm / w, 4.0);
	float result = 1.25f/4.0f * pow(Bretschneider_wm,4.0) * Hs*Hs * pow(w, -5.0) * exp(expTerm);
	return result;
}


// Ochi, Six-Parameter wave spectra, 1976
float OchiSingle(float w, float l, float wm, float hs) {

	float aux = (4.0 * l + 1.0) / 4.0f;
	return 0.25f * pow(aux * pow(wm, 4.0),float(l)) / gamma_impl(l) * pow(hs, 2.0) / pow(w, 4.0 * l + 1.0) * exp(-aux* pow(wm / w, 4.0));
}


float Ochi(float w, float l1, float wm1, float hs1, float l2, float wm2, float hs2) {

	return float(OchiSingle(w, l1, wm1, hs1)) + float(OchiSingle(w, l2, wm2, hs2));
}


float OchiHs(float w) {
	return Ochi(w, 3.0, 0.7f * exp(-0.046f * Hs), 0.84f * Hs,1.54f * exp(-0.062f *  Hs), 1.15f * exp(-0.039f * Hs), 0.54f* Hs);
}


// From Hasselman et. al 1973
float JONSWAP(float windSpeed, float w, float fetch) 
{    
	float dimensionlessFetch = G * fetch / pow(windSpeed,2.0);
	float wp = 22.0 * (G/windSpeed) * pow(dimensionlessFetch, -0.33);
	float expTerm = -1.25 * pow(wp/w, 4.0);
	
	float sigma = JONSWAP_sigmaB;
	if (w <= wp)
		sigma = JONSWAP_sigmaA;	
	float gamaExp = 0.5 * pow((w - wp) /(sigma * wp), 2.0); 
	
	float alpha = 0.076 * pow(dimensionlessFetch, -0.22);
	
	float result = alpha * G * G * pow(w, -5.0) * exp(expTerm) * pow(JONSWAP_gamma, exp(-gamaExp));
	
	return result;
}


// Donelan et al (1985) proposed a modification to the JONSWAP spectral form
float DonnelanJONSWAP(float windSpeed, float w, float fetch) 
{
	float dimensionlessFetch = G * fetch / pow(windSpeed, 2.0);
	float Omega = 11.6f * pow(dimensionlessFetch, -0.23f);

	// wp from JONSWAP
	float wp = 22.0 * (G/windSpeed) * pow(dimensionlessFetch, -0.33);
	Omega = wp * windSpeed / G;
	//float wp = Omega * (G / windSpeed);
	float expTerm = -pow(wp / w, 4.0);

	float sigma = 0.08f * (1.0 + 4.0 / pow(Omega,3.0));

	float gamaExp = 0.5 * pow((w - wp) /(sigma * wp), 2.0); 

	float beta = 0.006f * pow(Omega, 0.55f);

	float gamma;
	if (Omega > 1.0)
		gamma = 1.7f + 6.0 * log(Omega);
	else
		gamma = 1.7f;

	float result = beta * G * G * pow(wp, -1.0) * pow(w, -4.0) * exp(expTerm) * pow(gamma, exp(-gamaExp));

	return result;
}


// From TMA, Hughes et al 1984
float TMA(float windSpeed, float w, float depth, float fetch) {


	float result = JONSWAP(windSpeed, w, fetch);

	float wh = clamp(w * sqrt(depth/G), 0.0, 2.0);
	float theta;
	if (wh <= 1.0)
		theta = 0.5 * wh*wh;
	else
		theta = 1.0-0.5*pow(2.0-wh, 2.0);
		
	clamp( theta,0.0,1.0);	
	
	return result * theta;
}


// From A unified directional spectrumfor long and short wind - driven waves
// T.Elfouhaily, B.Chapron, and K.Katsaros
// https://archimer.ifremer.fr/doc/00091/20226/
float omega(float k) {
	float km = 370.0;
	return (sqrt(G * k * (1.0 + pow(k / km, 2.0)))); // eq 24.
}


float Unified(vec2 kvec, vec2 khat) {

	float k = length(kvec);
	if (k == 0.0f)
		return 0.0f;

	float X = G * fetch / pow(windSpeed, 2.0); // after eq. 4

	float X0 = 2.2e4f;
	float Omega = 0.84f * pow(tanh(pow(X / X0, 0.4f)), -0.75f); // eq. 37

	float kp = G * pow(Omega / windSpeed, 2.0); // below eq. 3

	float c = omega(k) / k; // wave phase speed
	float cp = omega(kp) / kp; // phase speed for peak frequency

	float alphap = 6e-3f * sqrt(Omega); // eq. 34

	float Lpm = exp(-1.25f * pow(kp / k, 2.0));  // eq. 2

	float sigma = 0.08f * (1.0 + 4.0 * pow(Omega, -3.0)); // below eq. 3
	float Gamma = exp(-0.5f * pow(sqrt(k / kp) - 1.0, 2.0) / pow(sigma, 2.0));
	float gamma = 1.7f;
	if (Omega > 1.0)
		gamma +=  6.0 * log(Omega);

	float Jp = pow(gamma, Gamma); // eq. 3

	float Fp = Lpm * Jp * exp(-Omega / sqrt(10.0) * (sqrt(k / kp) - 1.0)); // eq. 32

	float Bl = 0.5f * alphap * (cp / c) * Fp; // eq. 31

	float cm = 0.23f; // between eq. 40 and 41

	float z0 = 3.7e-5f * pow(windSpeed, 2.0) / G * pow(windSpeed / cp, 0.9f); // eq. 66

	// https://en.wikipedia.org/wiki/Von_K%C3%A1rm%C3%A1n_constant
	float K = 0.41f;
	float ustar = K * windSpeed / log(10.0f / z0); // eq. 60

	float alpham = 0.01f;
	if (ustar < cm) // eq 44
		alpham *= (1.0 + log(ustar / cm));
	else
		alpham *= (1.0 + 3.0 * log(ustar / cm));

	float km = 370.0;
	float Fm = exp(-0.25f * pow(k / km - 1.0, 2.0));

	float Bh = 0.5f * alpham * (cm / c) * Fm * Lpm; // eq. 40 (fixed ? )

	float a0 = log(2.0) / 4.0;
	float ap = 4.0;
	float am = 0.13f * ustar / cm;
	float delta = tanh(a0 + ap * pow(c / cp, 2.5f) + am * (pow(cm / c, 2.5f))); // eq. 57

	float cos_twice_angle = 2.0 * pow(dot(windDir,khat), 2.0) - 1.0;
	return 1.0 / (2.0 * M_PI) * pow(k, -4.0) * (Bl + Bh) * (1.0 + delta * cos_twice_angle); // eq. 67
}



float getSpectrum(int spectrum, vec2 k_vec, float L, vec2 windDir, float windSpeed, int directionalMode, int dispersionMode, int propagate, float depth, float fetch, float swell) {


	if (k_vec == vec2(0,0))
		return 0.0;
		
	float res;
	float amplitudeCorrection = pow(2.0 * M_PI/L, 2.0);//2.0 * M_PI/L;//
	
	if (propagate == 1) {
		if (dot(k_vec, windDir) <= 0.0) {
			return 0.0;
		}
		else {
			amplitudeCorrection *= 2.0;
		}
	}
	
	float k = length(k_vec);
	vec2 k_hat = normalize(k_vec);
	float aux1;
	float w = getDispersionW(k, depth, dispersionMode);
		
	//imageStore(texF, ivec2(gl_GlobalInvocationID.xy), vec4(directionalMode, spectrum, 3, 4));

	switch(spectrum) {
		case SPECTRUM_PHILLIPS:
			res = Phillips(k_vec, windSpeed, windDir);
			break;
		case SPECTRUM_PIERSON_MOSKOWITZ:
			res = Pierson_Moskowitz(windSpeed, w);
			res *= getDirectionalSpreading(directionalMode, w, 0.877*G/windSpeed, k_hat, windDir, windSpeed, swell);
			res *= getDispersionDerivative(k, depth, dispersionMode) / k;
			break;
		case SPECTRUM_JONSWAP:
			res = JONSWAP(windSpeed, w, fetch);
			aux1 = G * fetch / pow(windSpeed,2.0);
			res *= getDirectionalSpreading(directionalMode, w, 22.0*(G/windSpeed) * pow(aux1, -0.33), k_hat, windDir, windSpeed, swell);
			res *= getDispersionDerivative(k, depth, dispersionMode) / k;
			break;
		case SPECTRUM_DONNELAN_JONSWAP:
			res = DonnelanJONSWAP(windSpeed, w, fetch);
			aux1 = G * fetch / pow(windSpeed,2.0);
			res *= getDirectionalSpreading(directionalMode, w, 22.0*(G/windSpeed) * pow(aux1, -0.33), k_hat, windDir, windSpeed, swell); 
			res *= getDispersionDerivative(k, depth, dispersionMode) / k;
			break;
		case SPECTRUM_TMA:
			res = TMA(windSpeed, w, depth, fetch);
			res *= getDirectionalSpreading(directionalMode, w, 22.0 * pow(G*G/(windSpeed*fetch), 0.33), k_hat, windDir, windSpeed, swell);
			res *= getDispersionDerivative(k, depth, dispersionMode) / k;
			break;
		case SPECTRUM_UNIFIED:
			res = Unified(k_vec, k_hat);
			break;
		case SPECTRUM_PIERSON_MOSKOWITZ_HS:
			res = PiersonMoskowitzHs(w);
			res *= getDirectionalSpreading(directionalMode, w, 0.4f * sqrt(G / Hs), k_hat, windDir, windSpeed, swell);
			res *= getDispersionDerivative(k, depth, dispersionMode) / k;
			break;
		case SPECTRUM_BRETSCHNEIDER:
			res = Bretschneider(w);
			res *= getDirectionalSpreading(directionalMode, w, 0.4f * sqrt(G / Hs), k_hat, windDir, windSpeed, swell);
			res *= getDispersionDerivative(k, depth, dispersionMode) / k;
			break;
		case SPECTRUM_OCHI:
			res = Ochi(w,Ochi_lambda1, Ochi_wm1, Ochi_Hs1, Ochi_lambda2, Ochi_wm2, Ochi_Hs2);
			res *= getDirectionalSpreading(directionalMode, w, 0.4f * sqrt(G / Hs), k_hat, windDir, windSpeed, swell);
			res *= getDispersionDerivative(k, depth, dispersionMode) / k;
			break;
		case SPECTRUM_OCHI_HS:
			res = OchiHs(w);
			res *= getDirectionalSpreading(directionalMode, w, 0.4f * sqrt(G / Hs), k_hat, windDir, windSpeed, swell);
			res *= getDispersionDerivative(k, depth, dispersionMode) / k;
			break;

	}	
	//amplitudeCorrection = 1;	
	return amplitudeCorrection * res ;
}

float rand(vec2 co){
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

void main(void) {

	vec2 hK, hminusK;

	ivec2 pos = ivec2(texCoordV * 512.0);
	
	int kx = pos.x >= width/2 ? pos.x - width: pos.x;
	int kz = pos.y >= width/2 ? pos.y - width: pos.y;
	float whalf = float(width) / 2.0;

	vec2 k = vec2(kx, kz) * 2.0 * M_PI/float(L);
	
	float aux = getSpectrum(spectrum, k, float(L), windDir, windSpeed, directionalMode,dispersionMode, propagate, depth, fetch, swell) * spectrumScale;
	
	float p = sqrt(aux * 0.5f);

	float z1, z2;

	// clamp to prevent values equal to zero
	vec4 z = clamp(vec4(rand(vec2(pos) + vec2(1000, 1000)), rand(vec2(pos) + vec2(2000, 2000)), rand(vec2(pos) + vec2(3000, 3000)), rand(vec2(pos) + vec2(4000, 4000))), 0.000001, 1.0);
	z1 = z.x-0.5;
	z2 = z.y-0.5;

	if (randomDistribution == RANDOM_NORMAL || randomDistribution == RANDOM_LOG) {
		// Box-Muller Transform
		// http://mathworld.wolfram.com/Box-MullerTransformation.html
		z1 = sqrt(-2.0*log(z.x))*cos(2.0 * M_PI * z.y);
		z2 = sqrt(-2.0*log(z.x))*sin(2.0 * M_PI * z.y);

		// https://www.quora.com/How-do-I-transform-between-log-normal-distribution-and-normal-distribution
		if (randomDistribution == RANDOM_LOG) {
			z1 = exp(z1);
			z2 = exp(z2);
		}
	}
	// https://stats.stackexchange.com/questions/234544/from-uniform-distribution-to-exponential-distribution-and-vice-versa
	else if (randomDistribution == RANDOM_EXP) {
		z1 = -log(z.x);
		z2 = -log(z.y);
	}
	hK = vec2(z1, z2) * p;
	
	// Box-Muller Transform
	float aux2 = getSpectrum(spectrum, -k, float(L), windDir, windSpeed, directionalMode, dispersionMode, propagate, depth, fetch, swell) * spectrumScale;
	p = sqrt(aux2 * 0.5);
	
	hminusK = vec2(z1, z2) * p;
	hminusK.y = -hminusK.y;
	
	//h0k = vec4(0.5, 0.4, 0.3, 1.0);
	h0k = vec4(hK.x, hK.y, hminusK.x, hminusK.y);
}

  </script>

  <script id="htkfs" type="notjs">
#version 300 es
precision mediump float;

// layers 
// VA is JXY
#define LAYER_Y_JXY_JXX_JYY 0
#define LAYER_DX_DZ_SX_SZ 1

// cascade layers
#define LAYER_Y	        0
#define LAYER_DX	    1
#define LAYER_DZ        2
#define LAYER_SX	    3
#define LAYER_SZ	    4
#define LAYER_VA_JXY	5
#define LAYER_JXX   	6
#define LAYER_JYY   	7

//#define TEXTURE_GRADS

//#define USE_NOISE

#define COMPUTE_SKY_FOR_REFLECTION

// foam
#define NO_FOAM 0
#define USE_JACOBIAN 1
#define USE_VERTICAL_ACCELERATION 2
#define FOAM USE_JACOBIAN

//#define TESTING_COLOR_DEPTHS
//#define TESTING_COLORS	


#define M_PI 3.1415926535897932384626433832795
#define G 9.81

#define RANDOM_UNIFORM 0
// normal dist can be computed with Box-Muller transform
#define RANDOM_NORMAL 1
// if X is from a normal distribution, then exp(X) follows a log distribution
#define RANDOM_LOG 2
// if X is uniform on [0,1] then âˆ’log(X) follows an exponential distribution
#define RANDOM_EXP 3


#define DISPERSION_DEEP 0
#define DISPERSION_SHALLOW 1
#define DISPERSION_ CAPILLARY 2 


#define DIRECTIONAL_COS_POWER 0
#define DIRECTIONAL_MITSUYASU 1
#define DIRECTIONAL_HASSELMANN 2
#define DIRECTIONAL_DONNELAN_BANNER 3
#define DIRECTIONAL_HORVATH_MITSUYASU 4
#define DIRECTIONAL_HORVATH_HASSELMANN 5
#define DIRECTIONAL_HORVATH_DONNELAN_BANNER 6

#define SPECTRUM_PHILLIPS 0
#define SPECTRUM_PIERSON_MOSKOWITZ 1
#define SPECTRUM_JONSWAP 2
#define SPECTRUM_DONNELAN_JONSWAP 3
#define SPECTRUM_TMA 4
#define SPECTRUM_UNIFIED 5
#define SPECTRUM_PIERSON_MOSKOWITZ_HS 6
#define SPECTRUM_BRETSCHNEIDER 7
#define SPECTRUM_OCHI 8
#define SPECTRUM_OCHI_HS 9


// ------------------------------
// Dispersion
// ------------------------------

float getDispersionW(float k, float depth, int dispersionMode) {

	float tension = 0.074; // N/m
	float density = 1000.0; // Kg/m3
	
	// deep waters
	if (dispersionMode == DISPERSION_DEEP) 
		return sqrt(k * G);
	// shallow waters	
	else if (dispersionMode == DISPERSION_SHALLOW)	
		return sqrt(k * G * tanh(k*depth));
	else  // DISPERSION_ CAPILLARY
		return sqrt((G * k + pow(k,3.0) * tension/density) * tanh(k*depth));
}


float getDispersionDerivative(float k, float depth, int dispersionMode) {

	float tension = 0.074; // N/m
	float density = 1000.0; // Kg/m3
	float w = getDispersionW(k, depth, dispersionMode);
	
	// deep waters
	if (dispersionMode == DISPERSION_DEEP) 
		return G * 0.5f / w; 
	// shallow waters	
	else if (dispersionMode == DISPERSION_SHALLOW) {
		float dk = depth * k;
		float th = tanh(dk);
		return 0.5f * sqrt(9.81f / (k*th)) * (th + dk*(1.0 - th*th));
	}
	else { // DISPERSION_ CAPILLARY
		float dk = depth * k;
		float th = tanh(dk);
		float b = tension/density;
		return 0.5f * ((9.81f + 3.0 * b*k*k)*th + dk * (k*k*b + 9.81f) * pow(1.0f / cosh(dk), 2.0)) / w;
	}
}


in vec2 texCoordV;

layout (location = 0) out vec4 htk_Layer0;
layout (location = 1) out vec4 htk_Layer1; 

uniform sampler2D h0k;

uniform int width;
uniform int L;
uniform float timer;
uniform int dispersionMode;
uniform float depth;


vec2 mult(vec2 v0, vec2 v1) {
	return vec2(v0.x * v1.x - v0.y * v1.y,
				v0.x * v1.y + v0.y * v1.x);
}

vec2 conj(vec2 v){
	return vec2(v.x, -v.y);
}

void main(void) {

//	imageStore(tilde_hkt, ivec3(gl_GlobalInvocationID.xy, LAYER_DY), 
//		texelFetch(tilde_h0k, ivec2(gl_GlobalInvocationID.xy),0));
//	return;	
	float t = (timer+1e7) / 1000.0;
	//float t = timer/1000;
	ivec2 pos = ivec2(texCoordV * 512.0);

	int kx = pos.x >= width/2 ? pos.x - width: pos.x;
	int kz = pos.y >= width/2 ? pos.y - width: pos.y;
	float whalf = float(width) / 2.0;

	vec2 k = vec2(kx, kz) * 2.0 * M_PI/float(L);
	
	float magnitude = length(k);
//	imageStore(tilde_hkt, ivec3(gl_GlobalInvocationID.xy, LAYER_DY), vec4(magnitude,depth,k));
//	return;	
	if (magnitude < 0.00000000001) magnitude = 0.00000000001;
	
	float w = getDispersionW(magnitude, depth, dispersionMode);
	
	vec4 spectrum = texelFetch(h0k, ivec2(texCoordV * 512.0),0);
	int x,y;
	x = (width - int(texCoordV.x * 512.0)) % width;
	y = (width - int(texCoordV.y * 512.0)) % width;
	vec4 spectrumC = texelFetch(h0k, ivec2(x,y),0);

	vec2 fourier_amp = spectrum.xy;
	vec2 fourier_amp_conj = spectrumC.xy;
	fourier_amp_conj.y = -fourier_amp_conj.y;
	
	float cosinus = cos(w*t);
	float sinus   = sin(w*t);
	vec2 exp_iwt = vec2(cosinus, sinus);
	vec2 exp_iwt_inv = vec2(cosinus, -sinus);

	// dy
	vec2 h_k_t_dy = mult(fourier_amp, exp_iwt) + mult(fourier_amp_conj, exp_iwt_inv);
//	imageStore(tilde_hkt, ivec3(gl_GlobalInvocationID.xy, LAYER_DY), vec4(h_k_t_dy, cosinus, sinus));
//	imageStore(tilde_hkt, ivec3(gl_GlobalInvocationID.xy, LAYER_DY), vec4(fourier_amp, fourier_amp_conj));
//	return;	

	// dx
	vec2 dx = vec2(0.0, -k.x/magnitude);
	vec2 h_k_t_dx = mult(dx, h_k_t_dy);
	
	// dz
	vec2 dz = vec2(0.0, -k.y/magnitude);
	vec2 h_k_t_dz = mult(dz, h_k_t_dy);
	
	// sx
	dx = vec2(0.0, k.x);
	vec2 sx = mult(dx, h_k_t_dy);

	// sz
	dz = vec2(0.0, k.y);
	vec2 sz = mult(dz, h_k_t_dy);
	
#if (FOAM == USE_VERTICAL_ACCELERATION)

	vec2 a0k = fourier_amp * w * w;
	vec2 a0minusk = fourier_amp_conj * w * w;
	vec2 a = mult(a0k, exp_iwt) + mult(a0minusk, exp_iwt_inv);
	vec2 b = vec2(0);
	
#elif (FOAM == USE_JACOBIAN)

	vec2 daux = vec2(0.0, -k.x);
	vec2 jxx = mult(daux, h_k_t_dx);
	vec2 a = mult(daux, h_k_t_dz);
	daux = vec2(0.0, -k.y);
	vec2 jyy = mult(daux, h_k_t_dz);
	vec2 b = jxx +vec2(-jyy.y, jyy.x);
//	imageStore(tilde_hkt, ivec3(gl_GlobalInvocationID.xy, LAYER_JXXYY), vec4(jxx, jyy));
	
#else
	vec2 a = vec2(0);
#endif
	vec2 dy = h_k_t_dy + vec2(-a.y, a.x);
	vec2 dxz = h_k_t_dx + vec2(-h_k_t_dz.y, h_k_t_dz.x);
	vec2 sxz = sx + vec2(-sz.y, sz.x);
	//imageStore(tilde_hkt, ivec3(texCoordV * 512, LAYER_Y_JXY_JXX_JYY), vec4(dy, b));
	//imageStore(tilde_hkt, ivec3(texCoordV * 512, LAYER_DX_DZ_SX_SZ), vec4(dxz,sxz));

	htk_Layer0 = vec4(dy.x, dy.y, b.x, b.y);
	htk_Layer1 = vec4(dxz.x, dxz.y, sxz.x, sxz.y);

//	imageStore(tilde_hkt, ivec3(gl_GlobalInvocationID.xy, LAYER_DXZ), vec4(h_k_t_dx, h_k_t_dz));
//	imageStore(tilde_hkt, ivec3(gl_GlobalInvocationID.xy, LAYER_SXZ), vec4(sx, sz));
	
}
  </script>

  <script id="ffthfs" type="notjs">
	#version 300 es
	
	// layers 
	// VA is JXY
	#define LAYER_Y_JXY_JXX_JYY 0
	#define LAYER_DX_DZ_SX_SZ 1
	
	// cascade layers
	#define LAYER_Y	        0
	#define LAYER_DX	    1
	#define LAYER_DZ        2
	#define LAYER_SX	    3
	#define LAYER_SZ	    4
	#define LAYER_VA_JXY	5
	#define LAYER_JXX   	6
	#define LAYER_JYY   	7
	
	//#define TEXTURE_GRADS
	
	//#define USE_NOISE
	
	#define COMPUTE_SKY_FOR_REFLECTION
	
	// foam
	#define NO_FOAM 0
	#define USE_JACOBIAN 1
	#define USE_VERTICAL_ACCELERATION 2
	#define FOAM USE_JACOBIAN
	
	//#define TESTING_COLOR_DEPTHS
	//#define TESTING_COLORS	
	
	
	#define M_PI 3.1415926535897932384626433832795
	#define G 9.81
	
	#define RANDOM_UNIFORM 0
	// normal dist can be computed with Box-Muller transform
	#define RANDOM_NORMAL 1
	// if X is from a normal distribution, then exp(X) follows a log distribution
	#define RANDOM_LOG 2
	// if X is uniform on [0,1] then âˆ’log(X) follows an exponential distribution
	#define RANDOM_EXP 3
	
	
	#define DISPERSION_DEEP 0
	#define DISPERSION_SHALLOW 1
	#define DISPERSION_ CAPILLARY 2 
	
	
	#define DIRECTIONAL_COS_POWER 0
	#define DIRECTIONAL_MITSUYASU 1
	#define DIRECTIONAL_HASSELMANN 2
	#define DIRECTIONAL_DONNELAN_BANNER 3
	#define DIRECTIONAL_HORVATH_MITSUYASU 4
	#define DIRECTIONAL_HORVATH_HASSELMANN 5
	#define DIRECTIONAL_HORVATH_DONNELAN_BANNER 6
	
	#define SPECTRUM_PHILLIPS 0
	#define SPECTRUM_PIERSON_MOSKOWITZ 1
	#define SPECTRUM_JONSWAP 2
	#define SPECTRUM_DONNELAN_JONSWAP 3
	#define SPECTRUM_TMA 4
	#define SPECTRUM_UNIFIED 5
	#define SPECTRUM_PIERSON_MOSKOWITZ_HS 6
	#define SPECTRUM_BRETSCHNEIDER 7
	#define SPECTRUM_OCHI 8
	#define SPECTRUM_OCHI_HS 9
	
	
	in vec2 texCoordV;
	
	// ping pong textures
	layout (location = 0) out vec4 out_Layer0;
	layout (location = 1) out vec4 out_Layer1;

	uniform sampler2D inTexture_Layer0;
	uniform sampler2D inTexture_Layer1;
	
	uniform int pingpong;
	uniform int log_width;
	uniform int stage;
	
	
	vec4 complexMultTwice(vec2 v0, vec4 v1) {
		return vec4(v0.x * v1.x - v0.y * v1.y,
					v0.x * v1.y + v0.y * v1.x,
					v0.x * v1.z - v0.y * v1.w,
					v0.x * v1.w + v0.y * v1.z);
	}
	
	
	vec2 w(int k, int nn) {
	
		float it =  2 * k * M_PI / nn;
		return vec2(cos(it), sin(it));
	}
	
	
	void main() {
		int line = int(texCoordV.x * 512);
		uint column = uint(texCoordV.y * 512); //cuidado
		
		int iter = int(pow(2,log_width-1));
		
		int halfGroupSize = int(pow(2, stage));
		int groupSize = 2 * halfGroupSize;
		int k = line % halfGroupSize;
		int group = line / halfGroupSize;
		int shift = int(pow(2, stage));
		int groupShift = shift * 2;
	
		int index = k + group * groupShift;
	
		vec2 ww = w(k, groupShift);
		
		vec4 elemk, elemks, elemxz, elemxzs; 
		
		if (stage == 0) {
		// when stage = 0 use bit reverse indices
			uint br = bitfieldReverse(uint(index));
			br = bitfieldExtract(br, 32 - log_width, log_width);
			uint brs = bitfieldReverse(uint(index + shift));
			brs = bitfieldExtract(brs, 32 - log_width, log_width);
			elemk = texture(inTexture_Layer0, vec2(br, column));
			elemk = texture(inTexture_Layer0, vec2(brs, column));
			elemk = texture(inTexture_Layer1, vec2(br, column));
			elemk = texture(inTexture_Layer1, vec2(brs, column));
		}
		else {
			elemk = texture(inTexture_Layer0, vec2(index, column));
			elemk = texture(inTexture_Layer0, vec2(index + shift), column));
			elemk = texture(inTexture_Layer1, vec2(index, column));
			elemk = texture(inTexture_Layer1, vec2(index + shift, column));
		}
		// compute the twiddle factor
		 
			
		// write the outputs
		vec4 cm = complexMultTwice(ww, elemks);
		out_Layer0 = elemk + cm;
		imageStore(pingpong1, ivec3(index, column, LAYER_Y_JXY_JXX_JYY), elemk + cm);
		imageStore(pingpong1, ivec3(index + shift, column, LAYER_Y_JXY_JXX_JYY), elemk - cm);
	
		cm = complexMultTwice(ww,elemxzs);
		imageStore(pingpong1, ivec3(index, column, LAYER_DX_DZ_SX_SZ), elemxz + cm);
		imageStore(pingpong1, ivec3(index + shift, column, LAYER_DX_DZ_SX_SZ), elemxz - cm);
	
	
	}
  </script>


  <script id="drawTex" type="notjs">
	#version 300 es
  	precision mediump float;
  	uniform sampler2D tex;
	in vec2 texCoordV;
  	out vec4 outColor;
  	void main() {
    	vec4 colors;
		colors = texture(tex, texCoordV * 512.0);
    	if(int(texCoordV.x * 512.0) == 10) outColor = vec4(1.0, 0.0, 0.0, 1.0);
      	else outColor = vec4(0.0, 1.0, 0.0, 1.0);
  	}
  </script>

  <script type="module">
    import * as twgl from './twgl-full.module.js';
    const gl = document.querySelector("#c").getContext("webgl2");
	gl.getExtension('EXT_color_buffer_float');
    gl.getExtension('EXT_float_blend');
    gl.getExtension('OES_texture_float_linear');

	const startMS = new Date();

	//------------------------------------------create textures-----------------------------------------------------

	const width = 512;
  	const height = 512;
	const level = 0;

	const h0k = gl.createTexture();
	gl.bindTexture(gl.TEXTURE_2D, h0k);

	gl.texImage2D(gl.TEXTURE_2D, level, gl.RGBA32F, width, height, 0, 
                gl.RGBA, gl.FLOAT, null);
  
  	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

	const htk_Layer0 = gl.createTexture();
	gl.bindTexture(gl.TEXTURE_2D, htk_Layer0);

	gl.texImage2D(gl.TEXTURE_2D, level, gl.RGBA32F, width, height, 0, 
                gl.RGBA, gl.FLOAT, null);
  
  	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

	const htk_Layer1 = gl.createTexture();
	gl.bindTexture(gl.TEXTURE_2D, htk_Layer1);

	gl.texImage2D(gl.TEXTURE_2D, level, gl.RGBA32F, width, height, 0, 
                gl.RGBA, gl.FLOAT, null);
  
  	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

	const pingpong_Layer0 = gl.createTexture();
	gl.bindTexture(gl.TEXTURE_2D, pingpong_Layer0);

	gl.texImage2D(gl.TEXTURE_2D, level, gl.RGBA32F, width, height, 0, 
                gl.RGBA, gl.FLOAT, null);
  
  	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

	const pingpong_Layer1 = gl.createTexture();
	gl.bindTexture(gl.TEXTURE_2D, pingpong_Layer1);

	gl.texImage2D(gl.TEXTURE_2D, level, gl.RGBA32F, width, height, 0, 
                gl.RGBA, gl.FLOAT, null);
  
  	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    

	//------------------------------------------h0k-----------------------------------------------------
	const h0kprogram = twgl.createProgramInfo(gl, ["vs", "h0kfs"]);
	const htkprogram = twgl.createProgramInfo(gl, ["vs", "htkfs"]);
	const ffthprogram = twgl.createProgramInfo(gl, ["vs", "ffthfs"]);

	const fb = gl.createFramebuffer();
  	gl.bindFramebuffer(gl.FRAMEBUFFER, fb);

	gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, h0k, level);
	
  	gl.useProgram(h0kprogram.program);

	gl.viewport(0, 0, width, height);

  	const arrays = {
    	position: [-1, -1, 0, 1, -1, 0, -1, 1, 0, -1, 1, 0, 1, -1, 0, 1, 1, 0],
     	texcoord: [0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1],
  	};

  	const bufferInfo = twgl.createBufferInfoFromArrays(gl, arrays);

  	console.log(gl.checkFramebufferStatus(gl.FRAMEBUFFER) == gl.FRAMEBUFFER_COMPLETE)
   
  	const uniforms = {
		fftTextureDim: 512,
		butterflyStage: 9,
		logOfWidth: 9,
		pingpongStatus: 0,
		currentLevelMipmap: 0,
		randomDistribution: 1,
		oceanDepth: 20,
		L: 512,
		spectrum: 1,
		dispersion: 0,
		dirSpreading: 0,
		spectrumScale: 1,
		choppyFactor: 1,
		fetch: 1200000.0,
		windDir: [1,0],
		windSpeed: 10.0,
		propagate: 1,
		swell: 0.0,
		Hs: 10.0,
		JONSWAP_gamma: 3.3,
		JONSWAP_sigmaB: 0.09,
		Bretschneider_wm: 0.0,
		Ochi_lambda1: 3.0,
		Ochi_lambda2: 0.0,
		Ochi_wm1: 0.0,
		Ochi_wm2: 0.0,
		Ochi_Hs1:  0.0,
		Ochi_Hs2: 0.0,
        oceanType: 1,
		oceanTrans: [ 98.2, 95.8, 57.0],
		oceanFloorColor: [0.956, 0.925, 0.925],
	};
	  
	twgl.setUniforms(h0kprogram, uniforms);	  
  	twgl.setBuffersAndAttributes(gl, h0kprogram, bufferInfo);
  	twgl.drawBufferInfo(gl, bufferInfo);

	var pixels = new Float32Array(512 * 512 * 4);
	gl.readPixels(0, 0, 512, 512, gl.RGBA, gl.FLOAT, pixels);
	console.log(pixels);

	//------------------------------------------htk-----------------------------------------------------
	
	
	gl.useProgram(htkprogram.program);

	gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, htk_Layer0, level);
	gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + 1, gl.TEXTURE_2D, htk_Layer1, level);

	gl.drawBuffers([
    gl.COLOR_ATTACHMENT0,
    gl.COLOR_ATTACHMENT1,
  ]);

  console.log(gl.checkFramebufferStatus(gl.FRAMEBUFFER) == gl.FRAMEBUFFER_COMPLETE)

  	const htkuniforms = {
		width: 512,
		oceanDepth: 20,
		L: 512,
		dispersion: 0,
		timer: new Date() - startMS,
		h0k: h0k
	};

	twgl.setUniforms(htkprogram, htkuniforms);	  
  	twgl.setBuffersAndAttributes(gl, htkprogram, bufferInfo);
  	twgl.drawBufferInfo(gl, bufferInfo);

/*
	//------------------------------------------fft-h-----------------------------------------------------

	var pingpong = 1;
	var current_stage = -1;
	var log_width = 9;
	var willRender = true;

	while(willRender){
		current_stage++;
		if(current_stage < log_width){
			pingpong = (pingpong[1] + 1) % 2;
			willRender = true;
		} else{
			willRender = false;
		}

		if(willRender == true){
			if(pingpong == 0){
				gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, pingpong_Layer0, level);
				gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + 1, gl.TEXTURE_2D, pingpong_Layer1, level);
				
				const htkuniforms = {
					pingpong: pingpong,
					log_width: log_width,
					stage: current_stage,
					inTexture_Layer0: htk_Layer0,
					inTexture_Layer1: htk_Layer1,
				};
			
			}
		}
	}
	*/

	//debug kinda
	const prgInfo2 = twgl.createProgramInfo(gl, ["vs", "drawTex"]);
  	gl.useProgram(prgInfo2.program);

  	gl.bindFramebuffer(gl.FRAMEBUFFER, null);

  	twgl.resizeCanvasToDisplaySize(gl.canvas);
  	gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

	const uniforms2={
		tex: htk_Layer1,
	}

	function render(){
		
		twgl.setUniforms(prgInfo2, uniforms2);
   		twgl.setBuffersAndAttributes(gl, prgInfo2, bufferInfo);
   		twgl.drawBufferInfo(gl, bufferInfo);

		requestAnimationFrame(render);
	}
	requestAnimationFrame(render);

	
  </script>
</html>


